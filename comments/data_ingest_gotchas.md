# Tile upload and data ingest notes

This document summarises a few things to be aware of when massaging data from transforms or Illustrator files prior to upload to the SMP.

## Spaces in Illustrator PDF filenames

Spaces in filenames tend to drive programmers nuts at the best of times because they need special handling to escape them in code. They're particularly bad for the tile upload process for lenses because we derive S3 folder names for the lens tiles from the source PDF filename. Say we have a lens called `distributors`, which has exported as a file called `~distributors_tiles.pdf` -- the tiles for this will end up being stored in S3 in the following location:

    s3://opatlas-live/mgs/20210928/overlays/distributors/

All well and good. Now say we have a lens called `Mars Inc`, which has exported as `~Mars Inc_tiles.pdf` - this will end up at

    s3://opatlas-live/mgs/20210928/overlays/Mars Inc/

And this is a problem, because when the client tries to load a tile from this bucket it's going to look for it at the following URL:

    https://opatlas-live.s3.eu-west-2.amazonaws.com/mgs/20210928/overlays/Mars Inc/0-0-0.png

But you can't have spaces in URLs! The URL gets truncated to `https://opatlas-live.s3.eu-west-2.amazonaws.com/mgs/20210928/overlays/Mars` and we get a 403 unauthorised response because that location doesn't exist.

We can work around this by doing some conversion of the filename during the tile slicing and exporting (so `Mars Inc` becomes `mars-inc`), but it is rather annoying. So please, **don't put spaces in your Illustrator filenames**. (Which I'm assuming are derived from names inside Illustrator.)

## Layer names and detail levels

Martin has made a Plectica map that visually illustrates how `forLayer` values are assembled [here](https://www.plectica.com/maps/PZLC28SP8/edit/S6MWLKKOF). 

Each label from the labels export has a `forLayer` triple (generated by a `layer` attribute in the Illustrator data) that tells the client which lenses/views and zoom/detail levels it should be displayed on. The format of `forLayer` should be as follows:

    <lens-name>@<detail-level-range>

The lens name is pretty simple -- if I want to display my labels under a lens called `distributors`, then I start my `forLayer` value with `distributors`.

The detail level range is a numerical range (or a single value). Zoom levels start at 0 and (usually) go up to 6. If I want my labels to display between zoom levels 4 and 6, then I pass a detail level range of `4-6`

This means a full, valid `forLayer` value would look something like `distributors@4-6`.

If I want my labels to display under *all* lenses/views, all of the time, then I just omit the lens name entirely and have a `forLayer` value that is just `@<detail-level-range>`, so `@4-6` or similar.

**forLayer values must adhere this format!**. If you try and pass something in a different format like `level-1` then the client won't parse it and your labels won't display at all. 

## Linking labels to stakeholder data from Excel workbooks

Consider a map that displays a set of stakeholder entities. The stakeholders and their attributes -- name, description, any relationships -- are defined in an Excel workbook and converted to RDF triples via a transform. However, the Excel workbook does not contain any information on how and where to display the stakeholders on the map. This information is provided by the labels export from Illustrator, which comes in the form of a .json file which is converted to triples by the `labels.py` script in `map-tools`.

We now have two sets of triples from the labels and the workbook that, when combined, would give us all of the data we need to display the stakeholders properly. We just need to link the two sets of data together so that the model knows they're referring to the same thing.

The default behaviour for the `labels.py` script in `map-tools` is to attach a `forThing` attribute to each labels that points at another IRI. The client uses this to attach labels to other objects in the data model with the `forThing` IRI. The format of the IRI is as follows:

    'vm:_thing_{row[qcontents].as_slug}'

`row[qcontents]` is the name of the stakeholder as represented on the label in Illustrator, and should match the name of the stakeholder in the workbook. The problem is that whatever transform is converting the workbook data into triples is probably formatting the stakeholder IRI like this:

    'vm:_stakeholder_{row[Category / Stakeholder name].as_slug}'

They're typed differently -- the labels IRI has the `_thing` prefix, while the workbook IRI has the `_stakeholder` prefix. The workbook version is more correct, but the labels has to use a more generic prefix because labels aren't just attached to stakeholders, they can go on painpoints, categories or just about anything.

So we need to create a linking reference that connects our `_thing`-typed IRI to our `_stakeholder`-typed one. This is done by inserting an extra triple into the workbook transform:

    'lets': {
        'iri': 'vm:_stakeholder_{row[Category / Stakeholder name].as_slug}',
    },
    'triples': [
        ...
        ('{iri}', 'owl:sameAs',
            'vm:_thing_{row[Category / Stakeholder name].as_slug}'),
    ],

This `owl:sameAs` triple is saying that the IRI `vm:_stakeholder_<stakeholder_name>` from the workbook is the same thing as the `vm:_thing_<stakeholder_name>` IRI from the labels data. When the client follows the `forThing` reference to the object the labels are supposed to be attached to, it will now find the data under `vm:_stakeholder` as it is supposed to.

Note that if you're doing this as part of a multistage transform where the transform data is being constructed as step one and then the labels data is being added as step two, you need to run any transforms containing `owl:sameAs` predicates with the `--no-resolve-same` argument in `sheet-to-triples`. This stops this aliasing being resolved until the second step of the process when the labels are added in.
